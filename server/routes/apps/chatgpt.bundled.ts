// This file is auto-generated by scripts/bundle-openai-script.js
// Do not edit directly - modify server/routes/apps/widget-runtime.ts instead

export const API_RUNTIME_SCRIPT =
  '"use strict";\n(() => {\n  // server/routes/apps/widget-runtime.ts\n  var CONFIG_ELEMENT_ID = "openai-runtime-config";\n  var readConfig = () => {\n    try {\n      const el = document.getElementById(CONFIG_ELEMENT_ID);\n      if (!el) {\n        console.error("[OpenAI Widget] Missing runtime config element");\n        return null;\n      }\n      const raw = el.textContent || "{}";\n      return JSON.parse(raw);\n    } catch (err) {\n      console.error("[OpenAI Widget] Failed to parse runtime config", err);\n      return null;\n    }\n  };\n  var clampNumber = (value) => {\n    const n = Number(value);\n    return Number.isFinite(n) ? n : null;\n  };\n  (function bootstrap() {\n    const config = readConfig();\n    if (!config) return;\n    const {\n      toolId,\n      toolName,\n      toolInput,\n      toolOutput,\n      toolResponseMetadata,\n      theme,\n      locale,\n      deviceType,\n      userLocation,\n      maxHeight,\n      capabilities,\n      safeAreaInsets,\n      viewMode = "inline",\n      viewParams = {},\n      useMapPendingCalls = true\n    } = config;\n    const widgetStateKey = `openai-widget-state:${toolName}:${toolId}`;\n    const hostLocale = locale;\n    const hostDeviceType = deviceType;\n    const hostUserLocation = userLocation ?? null;\n    const hostCapabilities = capabilities ?? null;\n    const hostSafeAreaInsets = safeAreaInsets ?? {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    try {\n      document.documentElement.lang = hostLocale;\n    } catch (e) {\n    }\n    const detectedTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;\n    const detectedHover = window.matchMedia("(hover: hover)").matches;\n    const hasTouch = hostCapabilities ? hostCapabilities.touch : detectedTouch;\n    const hasHover = hostCapabilities ? hostCapabilities.hover : detectedHover;\n    const getSubjectId = () => {\n      let subjectId = sessionStorage.getItem("openai_subject_id");\n      if (!subjectId) {\n        subjectId = "anon_" + Math.random().toString(36).substring(2, 15);\n        sessionStorage.setItem("openai_subject_id", subjectId);\n      }\n      return subjectId;\n    };\n    const postHeight = /* @__PURE__ */ (() => {\n      let lastHeight = 0;\n      return (height) => {\n        const numericHeight = Number(height);\n        if (!Number.isFinite(numericHeight) || numericHeight <= 0) return;\n        const roundedHeight = Math.round(numericHeight);\n        if (roundedHeight === lastHeight) return;\n        lastHeight = roundedHeight;\n        window.parent.postMessage(\n          { type: "openai:resize", height: roundedHeight },\n          "*"\n        );\n      };\n    })();\n    const measureAndNotifyHeight = () => {\n      try {\n        let contentHeight = 0;\n        if (document.body) {\n          const children = document.body.children;\n          for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.tagName === "SCRIPT" || child.tagName === "STYLE") continue;\n            const rect = child.getBoundingClientRect();\n            const bottom = rect.top + rect.height + window.scrollY;\n            contentHeight = Math.max(contentHeight, bottom);\n          }\n          const bodyStyle = window.getComputedStyle(document.body);\n          contentHeight += parseFloat(bodyStyle.marginBottom) || 0;\n          contentHeight += parseFloat(bodyStyle.paddingBottom) || 0;\n        }\n        if (contentHeight <= 0) {\n          const docEl = document.documentElement;\n          contentHeight = Math.max(\n            docEl ? docEl.scrollHeight : 0,\n            document.body ? document.body.scrollHeight : 0\n          );\n        }\n        postHeight(Math.ceil(contentHeight));\n      } catch (err) {\n        console.error("[OpenAI Widget] Failed to measure height:", err);\n      }\n    };\n    const setupAutoResize = () => {\n      let scheduled = false;\n      const scheduleMeasure = () => {\n        if (scheduled) return;\n        scheduled = true;\n        requestAnimationFrame(() => {\n          scheduled = false;\n          measureAndNotifyHeight();\n        });\n      };\n      scheduleMeasure();\n      if (typeof ResizeObserver !== "undefined") {\n        const resizeObserver = new ResizeObserver(scheduleMeasure);\n        resizeObserver.observe(document.documentElement);\n        if (document.body) resizeObserver.observe(document.body);\n      } else {\n        window.addEventListener("resize", scheduleMeasure);\n      }\n      window.addEventListener("load", () => {\n        requestAnimationFrame(measureAndNotifyHeight);\n      });\n    };\n    const navigationState = { currentIndex: 0, historyLength: 1 };\n    const withNavigationIndex = (state, index) => {\n      return state && typeof state === "object" ? { ...state, __navIndex: index } : { __navIndex: index };\n    };\n    const notifyNavigationState = () => {\n      const canGoBack = navigationState.currentIndex > 0;\n      const canGoForward = navigationState.currentIndex < navigationState.historyLength - 1;\n      window.parent.postMessage(\n        {\n          type: "openai:navigationStateChanged",\n          toolId,\n          canGoBack,\n          canGoForward,\n          historyLength: navigationState.historyLength,\n          currentIndex: navigationState.currentIndex\n        },\n        "*"\n      );\n    };\n    const originalPushState = history.pushState.bind(history);\n    history.pushState = function pushState(state, title, url) {\n      const nextIndex = navigationState.currentIndex + 1;\n      const stateWithIndex = withNavigationIndex(state, nextIndex);\n      originalPushState(stateWithIndex, title, url);\n      navigationState.currentIndex = nextIndex;\n      navigationState.historyLength = history.length;\n      notifyNavigationState();\n    };\n    const originalReplaceState = history.replaceState.bind(history);\n    history.replaceState = function replaceState(state, title, url) {\n      const stateWithIndex = withNavigationIndex(\n        state,\n        navigationState.currentIndex\n      );\n      originalReplaceState(stateWithIndex, title, url);\n      navigationState.historyLength = history.length;\n      notifyNavigationState();\n    };\n    window.addEventListener("popstate", (event) => {\n      const stateIndex = event.state?.__navIndex ?? navigationState.currentIndex;\n      navigationState.currentIndex = stateIndex;\n      navigationState.historyLength = history.length;\n      notifyNavigationState();\n    });\n    const openaiAPI = {\n      toolInput,\n      toolOutput,\n      toolResponseMetadata: toolResponseMetadata ?? null,\n      displayMode: "inline",\n      theme,\n      locale: hostLocale,\n      maxHeight: maxHeight ?? null,\n      safeArea: { insets: hostSafeAreaInsets },\n      userAgent: {\n        device: { type: hostDeviceType },\n        capabilities: { hover: hasHover, touch: hasTouch }\n      },\n      view: { mode: viewMode, params: viewParams },\n      widgetState: null,\n      ...useMapPendingCalls ? { _pendingCalls: /* @__PURE__ */ new Map() } : {},\n      _callId: 0,\n      setWidgetState(state) {\n        this.widgetState = state;\n        try {\n          localStorage.setItem(widgetStateKey, JSON.stringify(state));\n        } catch (err) {\n        }\n        window.parent.postMessage(\n          { type: "openai:setWidgetState", toolId, state },\n          "*"\n        );\n      },\n      callTool(toolName2, args = {}) {\n        const callId = ++this._callId;\n        if (useMapPendingCalls) {\n          return new Promise((resolve, reject) => {\n            this._pendingCalls.set(callId, { resolve, reject });\n            window.parent.postMessage(\n              {\n                type: "openai:callTool",\n                toolName: toolName2,\n                args,\n                callId,\n                toolId,\n                _meta: Object.assign(\n                  {\n                    "openai/locale": hostLocale,\n                    "openai/userAgent": navigator.userAgent,\n                    "openai/subject": getSubjectId()\n                  },\n                  hostUserLocation ? { "openai/userLocation": hostUserLocation } : {}\n                )\n              },\n              "*"\n            );\n            setTimeout(() => {\n              if (this._pendingCalls.has(callId)) {\n                this._pendingCalls.delete(callId);\n                reject(new Error("Tool call timeout"));\n              }\n            }, 3e4);\n          });\n        }\n        return new Promise((resolve, reject) => {\n          const handler = (event) => {\n            if (event.data?.type === "openai:callTool:response" && event.data.callId === callId) {\n              window.removeEventListener("message", handler);\n              event.data.error ? reject(new Error(event.data.error)) : resolve(event.data.result);\n            }\n          };\n          window.addEventListener("message", handler);\n          window.parent.postMessage(\n            {\n              type: "openai:callTool",\n              callId,\n              toolName: toolName2,\n              args,\n              toolId,\n              _meta: Object.assign(\n                {\n                  "openai/locale": hostLocale,\n                  "openai/userAgent": navigator.userAgent,\n                  "openai/subject": getSubjectId()\n                },\n                hostUserLocation ? { "openai/userLocation": hostUserLocation } : {}\n              )\n            },\n            "*"\n          );\n          setTimeout(() => {\n            window.removeEventListener("message", handler);\n            reject(new Error("Tool call timeout"));\n          }, 3e4);\n        });\n      },\n      sendFollowUpMessage(opts) {\n        const prompt = typeof opts === "string" ? opts : opts?.prompt || "";\n        window.parent.postMessage(\n          { type: "openai:sendFollowup", message: prompt, toolId },\n          "*"\n        );\n      },\n      sendFollowupTurn(message) {\n        return this.sendFollowUpMessage(\n          typeof message === "string" ? message : message?.prompt || ""\n        );\n      },\n      requestDisplayMode(options = {}) {\n        const mode = options.mode || "inline";\n        this.displayMode = mode;\n        window.parent.postMessage(\n          {\n            type: "openai:requestDisplayMode",\n            mode,\n            maxHeight: options.maxHeight,\n            toolId\n          },\n          "*"\n        );\n        return { mode };\n      },\n      requestClose() {\n        window.parent.postMessage({ type: "openai:requestClose", toolId }, "*");\n      },\n      openExternal(options) {\n        let href;\n        if (typeof options === "string") {\n          console.warn(\n            "[OpenAI SDK] openExternal(string) is deprecated. Use openExternal({ href: string }) instead."\n          );\n          href = options;\n        } else {\n          href = options?.href;\n        }\n        if (!href)\n          throw new Error(\n            \'href is required for openExternal. Usage: openExternal({ href: "https://..." })\'\n          );\n        window.parent.postMessage({ type: "openai:openExternal", href }, "*");\n        window.open(href, "_blank", "noopener,noreferrer");\n      },\n      requestModal(options) {\n        window.parent.postMessage(\n          {\n            type: "openai:requestModal",\n            title: options.title,\n            params: options.params,\n            anchor: options.anchor\n          },\n          "*"\n        );\n      },\n      notifyIntrinsicHeight(height) {\n        postHeight(height);\n      },\n      notifyNavigation(direction) {\n        if (direction === "back") {\n          if (navigationState.currentIndex > 0) {\n            navigationState.currentIndex--;\n            history.back();\n          }\n        } else if (direction === "forward") {\n          if (navigationState.currentIndex < navigationState.historyLength - 1) {\n            navigationState.currentIndex++;\n            history.forward();\n          }\n        }\n      }\n    };\n    Object.defineProperty(window, "openai", {\n      value: openaiAPI,\n      writable: false,\n      configurable: false,\n      enumerable: true\n    });\n    Object.defineProperty(window, "webplus", {\n      value: openaiAPI,\n      writable: false,\n      configurable: false,\n      enumerable: true\n    });\n    setTimeout(() => {\n      try {\n        window.dispatchEvent(\n          new CustomEvent("openai:set_globals", {\n            detail: {\n              globals: {\n                displayMode: openaiAPI.displayMode,\n                maxHeight: openaiAPI.maxHeight,\n                theme: openaiAPI.theme,\n                locale: openaiAPI.locale,\n                safeArea: openaiAPI.safeArea,\n                userAgent: openaiAPI.userAgent\n              }\n            }\n          })\n        );\n      } catch (err) {\n        console.error("[OpenAI Widget] Failed to dispatch globals event:", err);\n      }\n    }, 0);\n    setTimeout(() => {\n      try {\n        const stored = localStorage.getItem(widgetStateKey);\n        if (stored && window.openai)\n          window.openai.widgetState = JSON.parse(stored);\n      } catch (err) {\n        console.error("[OpenAI Widget] Failed to restore widget state:", err);\n      }\n    }, 0);\n    window.addEventListener("message", (event) => {\n      const { type, callId, result, error, globals } = event.data || {};\n      switch (type) {\n        case "openai:callTool:response": {\n          if (!useMapPendingCalls) break;\n          const pending = window.openai._pendingCalls?.get(callId);\n          if (pending) {\n            window.openai._pendingCalls?.delete(callId);\n            error ? pending.reject(new Error(error)) : pending.resolve(result);\n          }\n          break;\n        }\n        case "openai:set_globals":\n          if (globals) {\n            if (globals.displayMode !== void 0)\n              window.openai.displayMode = globals.displayMode;\n            if (globals.maxHeight !== void 0)\n              window.openai.maxHeight = globals.maxHeight;\n            if (globals.theme !== void 0) window.openai.theme = globals.theme;\n            if (globals.locale !== void 0)\n              window.openai.locale = globals.locale;\n            if (globals.safeArea !== void 0)\n              window.openai.safeArea = globals.safeArea;\n            if (globals.userAgent !== void 0)\n              window.openai.userAgent = globals.userAgent;\n            if (globals.view !== void 0) window.openai.view = globals.view;\n          }\n          try {\n            window.dispatchEvent(\n              new CustomEvent("openai:set_globals", { detail: { globals } })\n            );\n          } catch (err) {\n          }\n          break;\n        case "openai:pushWidgetState":\n          if (event.data.toolId === toolId) {\n            try {\n              const nextState = event.data.state ?? null;\n              window.openai.widgetState = nextState;\n              try {\n                localStorage.setItem(widgetStateKey, JSON.stringify(nextState));\n              } catch (err) {\n              }\n              window.dispatchEvent(\n                new CustomEvent("openai:widget_state", {\n                  detail: { state: nextState }\n                })\n              );\n            } catch (err) {\n              console.error(\n                "[OpenAI Widget] Failed to apply pushed widget state:",\n                err\n              );\n            }\n          }\n          break;\n        case "openai:requestResize":\n          measureAndNotifyHeight();\n          break;\n        case "openai:navigate":\n          if (event.data.toolId === toolId) {\n            if (event.data.direction === "back") {\n              if (navigationState.currentIndex > 0) {\n                navigationState.currentIndex--;\n                history.back();\n              }\n            } else if (event.data.direction === "forward") {\n              if (navigationState.currentIndex < navigationState.historyLength - 1) {\n                navigationState.currentIndex++;\n                history.forward();\n              }\n            }\n          }\n          break;\n      }\n    });\n    window.addEventListener("openai:resize", (event) => {\n      try {\n        const detail = event && typeof event === "object" && "detail" in event ? event.detail || {} : {};\n        const height = typeof detail?.height === "number" ? detail.height : typeof detail?.size?.height === "number" ? detail.size.height : null;\n        if (height != null) {\n          postHeight(height);\n        } else {\n          measureAndNotifyHeight();\n        }\n      } catch (err) {\n        console.error("[OpenAI Widget] Failed to process resize event:", err);\n      }\n    });\n    setupAutoResize();\n    document.addEventListener("securitypolicyviolation", (e) => {\n      const violation = {\n        type: "openai:csp-violation",\n        toolId,\n        directive: e.violatedDirective,\n        blockedUri: e.blockedURI,\n        sourceFile: e.sourceFile || null,\n        lineNumber: clampNumber(e.lineNumber),\n        columnNumber: clampNumber(e.columnNumber),\n        originalPolicy: e.originalPolicy,\n        effectiveDirective: e.effectiveDirective,\n        disposition: e.disposition,\n        timestamp: Date.now()\n      };\n      console.warn(\n        "[OpenAI Widget CSP Violation]",\n        violation.directive,\n        ":",\n        violation.blockedUri\n      );\n      window.parent.postMessage(violation, "*");\n    });\n  })();\n})();\n';
